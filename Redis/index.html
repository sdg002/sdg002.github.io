<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <title>.NET Core - How to use Redis Cache to boost application performance?</title>
    <style>
        body {
            font-family: Arial
        }
    </style>
</head>


<body>
    <h1>About</h1>
    <p>
        Redis is a very powerful distributed caching engine and offers very low latency key-value pair caching. If used in the right business context, 
        Redis can significantly boost application performance.
        In this article we will do a walk through of how to use Redis Cache from a .NET Core Serverless HTTP function. 
        I intend to demonstrate the simplicity and elegance of Redis caching through the following topics:
        <ol>
            <li>Installing Redis locally and on Azure</li>
            <li>Using the command line tools of Redis</li>
            <li>Scripting the installation of Azure Redis via PowerShell and ARM templates</li>
            <li>Writing some sample C# code to demonstrate the key-value pair caching aspect of Redis using a sample Azure HTTP trigger function</li>
            <li>Benchmarking the latency and throughput of Redis using simple C# client code</li>
        </ol>
    </p>
    <hr />

    <h1>What is a distributed cache?</h1>
    <p>
        What is a cache? Think of it as a repository of frequently used data which can be accessed very speedily, thereby improving application performance.
        If we go back to the early days of .NET Framework 1.0, ASP.NET provided a means of caching objects in the memory of the worker process.
        The cached data was confined to the local server. If your objects supported binary serialization then using the in-proc Cache was fairly easy.
        It was all fine until you faced the need for scaling out your web servers to more than one instance. How do you keep the in-proc cache on 2 or more web servers in sync.

        <br />
        <img src="images/Cache-inproc.png" />
        <br />
        <br />

        In the scenario of a load balanced farm with more than one web servers, if Web server 1 made an update to a record and invalidated its cache, there is no way for Web server 2 to get that knowledge

        This is where distributed cache products like Memcached and Redis change the game by taking the cache out of the local web server and placing it on an external server(s).
        Notice the plural. Yes - the distributed cache could itself scale out horizontally.

        <br />
        <img src="images/Cache-distributed.png" />
        <br />
        <br />
        [you need to create the above images]
    </p>
    <hr />

    <h1>What is not a distributed cache?</h1>
    <p>
        NOT REQUIRED

        Talk about earliest versions of caching (ASP.NET)

    </p>
    <hr />

    <h1>Scenarios where a distributed cache helps</h1>
    <h2>Landing page of a news web site</h2>
    <p>bbc.co.uk
        Show picture
    </p>
    <h2>Shopping cart of an eCommerce portal</h2>
    <p>
        Amazon - Show the shopping cart of Amazon
    </p>
    <h2>Any application which has lots of static data or infrequently changing data</h2>
    <p>
        Any line of business application where there is infrequently changing static data held in the database. 
        Example - Relational tables which store lookup data like countries, item codes, and static customer information. 
        For most practical purposes there is a lot of mileage to gain if round trips to the database can be minimized.
    </p>
    <hr />

    <h1>Scenarios where caching is not always helpful</h1>
    <p>
        think!think!
    </p>
    <hr />

    <h1>A bief history of caching in the Microsoft world</h1>
    <p>
        <ol>
            <li><strong>ASP.NET Cache</strong>: When Microsoft introduced ASP.NET , a light weight in-memory cache came along with the framework. </li>
            <li><strong>Session state server</strong>: An integral part of .NET Framework. This was an executable that let multiple web servers store their session data in the process memory of this executable. You could re-configure your web.config and have all session state stored in a central server, independent of any single web server in a load balanced farm.</li>
            <li><strong>Microsoft Appfabric</strong>: Microsoft's attempt to go for a full blown distributed cache. Microsoft has ended support for this product </li>
            <li>Third party products like NCache, Memcached and Redis</li>
        </ol>
    </p>
    <hr />

    <h1>ASP.NET Framework Cache</h1>
    <p>
        to be done (talk about serialization, page caching, session state caching)
    </p>
    <hr />

    <h1>Memcached</h1>
    <p>
        to be done
    </p>
    <hr />


    <h1>Microsoft AppFabric</h1>
    <p>to be done</p>
    <hr />

    <h1>Redis</h1>
    <p>to be done</p>
    <hr />

    <h1>Using Redis for local development</h1>
    <p>
        to be done
    </p>
    <hr />

    <h1>Installing Redis locally on Windows</h1>
    <p>
        - Where to install Windows binaries?
        Redis server sets up a TCP/IP server.
        The Redis server can be run as follows
        - Open a CMD prompt
        - Navigate to the folder where the redis-server.exe was extracted
        - You should see a file redis.conf in this folder
        - The port number is specified in this (Usually 6379)
        - Launch redis server with the following command
    </p>
    <pre>
    c:\redis-server
    The log messages on the console will help affirming the actual port number

    </pre>
    <hr />


    <h1>Redis command line client</h1>
    <h2>How to launch?</h2>
    <pre>
    ```
    redis-cli.exe -h localhost -p 6379
    ```
    </pre>

    <h2>List all keys</h2>
    <pre>
    redis localhost:6379> keys *

    39) "foo:rand:000000000016"
    40) "foo:rand:000000000017"
    41) "foo:rand:000000000018"
    42) "foo:rand:000000000019"
    43) "mykey-f9d21bca-48f6-4cf8-b68d-1652b9533633"
    44) "mykey-43d5b08a-5b60-4c72-8820-dcb6f6372b4b"

    </pre>

    <h2>Delete a specific key</h2>
    <pre>
    redis localhost:6379> del mykey-0001
    </pre>

    <h2>Delete all keys</h2>

    <pre>
    redis localhost:6379> flushall
    </pre>

    <hr />


    <h1>C# client application  - Programming with StackExchange general purpose client</h1>

    <pre>
    ```
    Install-Package StackExchange.Redis
    ```
    </pre>

    <h2>C# client application  - Programming with IDistributedCache</h2>
    <p>to be done</p>

    <h2>Dependency injection</h2>
    <p>to be done</p>

    <h2>Is it compulsory to intall Redis server locally?</h2>
    <p>to be done</p>


    <h2>Is it compulsory to intall Redis server locally?</h2>
    <p>to be done</p>

    <hr />
    <h1>Getting started with Redis on Azure</h1>

    <h2>Creating a Redis cache using the Portal</h2>
    <p>to be done</p>
    <h2>Creating a Redis cache using PowerShell</h2>
    <p>to be done</p>

    <h2>ARM templates</h2>
    <p>
        https://github.com/Azure/azure-quickstart-templates/tree/master/101-redis-cache
    </p>

    <h2>How to get the connection string?</h2>

    <pre>
        $cn=blah-getrediscnstring
    </pre>

    <pre>
        [TestMethod]
        public void Basic_Set_And_Get()
        {
            IDatabase db = _redis.GetDatabase();

            for (int i = 0; i < MAXITEMCOUNT; i++)
            {
                string key = $"mykey-{Guid.NewGuid()}";
                string value = $"abcdefg-{Guid.NewGuid()}";
                db.StringSet(key, value);
                string valueFromCache = db.StringGet(key);
                Trace.WriteLine($"Value of key:{key}, value:{valueFromCache}");
                Assert.AreEqual(valueFromCache, value);
            }
        }
    </pre>
    <hr />

    <h1>Advanced features of Redis not discussed here</h1>
    <p>
        to be done. A short bulleted list
    </p>


</body>
</html>