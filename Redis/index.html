<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <title>.NET Core - How to use Redis Cache to boost application performance?</title>
    <style>
        body {
            font-family: Arial
        }
    </style>
</head>


<body>
    <h1>About</h1>
    <p>
        Redis is a very powerful distributed caching engine and offers very low latency key-value pair caching. If used in the right business context,
        Redis can significantly boost application performance.
        In this article we will do a walk through of how to use Redis Cache from a .NET Core Serverless HTTP function.
        I intend to demonstrate the simplicity and elegance of Redis caching through the following topics:
        <ol>
            <li>Installing Redis locally and on Azure</li>
            <li>Using the command line tools of Redis</li>
            <li>Scripting the installation of Azure Redis via PowerShell and ARM templates</li>
            <li>Writing some sample C# code to demonstrate the key-value pair caching aspect of Redis using a sample Azure HTTP trigger function</li>
            <li>Benchmarking the latency and throughput of Redis using simple C# client code</li>
        </ol>
    </p>
    <hr />

    <h1>What is a distributed cache?</h1>
    <p>
        What is a cache? Think of it as a repository of frequently used data which can be accessed very speedily, thereby improving application performance.
        If we go back to the early days of .NET Framework 1.0, ASP.NET provided a means of caching objects in the memory of the worker process.
        The cached data was confined to the local server. If your objects supported binary serialization then using the in-proc Cache was fairly easy.
        It was all fine until you faced the need for scaling out your web servers to more than one instance. How do you keep the in-proc cache on 2 or more web servers in sync.

        <br />
        <img src="images/Cache-inproc.PNG" />
        <br />
        <br />

        In the scenario of a load balanced farm with more than one web servers, if Web server 1 made an update to a record and invalidated its cache, there is no way for Web server 2 to get that knowledge

        This is where distributed cache products like Memcached and Redis change the game by taking the cache out of the local web server and placing it on an external server(s).
        Notice the plural. Yes - the distributed cache could itself scale out horizontally.

        <br />
        <img src="images/Cache-distributed.PNG" />
        <br />
        <br />
        [you need to create the above images]
    </p>
    <hr />

    <h1>What is not a distributed cache?</h1>
    <p>
        NOT REQUIRED

        Talk about earliest versions of caching (ASP.NET)

    </p>
    <hr />

    <h1>Scenarios where a distributed cache helps</h1>
    <h2>Landing page of a news web site</h2>
    <p>
        If you were to hit <a href="http://bbc.co.uk">bbc.co.uk</a>, one cannot help but notice how fast the page gets loaded. 
        I am not privy to the knowledge if BBC is using Redis or any other caching technology or it could just be a case of a super-fast CMS database. 
        However, the site is an example of what a good page load response time should be and 
        can be fairly easily implemented by caching.<br />
        <img src="images/bbc.png"/>
    </p>
    <h2>Shopping cart of an eCommerce portal</h2>
    <p>
        TO BE DONE  - Amazon - Show the shopping cart of Amazon
    </p>
    <h2>Any application which has lots of static data or infrequently changing data</h2>
    <p>
        Any line of business application where there is infrequently changing static data held in the database.
        Example - Relational tables which store lookup data like countries, item codes, and static customer information.
        For most practical purposes there is a lot of mileage to gain if round trips to the database can be minimized.
    </p>
    <hr />

    <h1>Scenarios where caching is not always helpful</h1>
    <p>
        think!think!
    </p>
    <hr />

    <h1>A bief history of caching in the Microsoft world</h1>
    <p>
        <ol>
            <li><strong>ASP.NET Cache</strong>: When Microsoft introduced ASP.NET , a light weight in-memory cache came along with the framework. </li>
            <li><strong>Session state server</strong>: An integral part of .NET Framework. This was an executable that let multiple web servers store their session data in the process memory of this executable. You could re-configure your web.config and have all session state stored in a central server, independent of any single web server in a load balanced farm.</li>
            <li><strong>Microsoft Appfabric</strong>: Microsoft's attempt to go for a full blown distributed cache. Microsoft has ended support for this product </li>
            <li>Third party products like NCache, Memcached and Redis</li>
        </ol>
    </p>
    <hr />

    <h1>ASP.NET Framework Cache</h1>
    <p>
        NOT SURE IF SHOULD REMOVE THIS - keep this for a later date
        show a simple code snippet
    </p>
    <hr />

    <h1>Memcached</h1>
    <p>
        to be done
    </p>
    <hr />


    <h1>Microsoft AppFabric</h1>
    <p>to be done</p>
    <hr />

    <h1>Redis</h1>
    <p>
        Redis is an open source distributed in-memory key-value pair database and message broker. The acronym stands for Remote Dictionary Server.
        Put simplistically, Redis is a daemon running on a Linux box and listening on incoming connections on a well published port such as 6379.
        Redis goes a step ahead of in-memory key-value databases by backing up transient data to a file which helps in rapid recovery in case of failures.
        It is more sophisticated than traditional in-memory key-value pair databases because it offers support for complex data types,custom server side scripting, partitioning and pub-sub capabilities.
        Example: A simple distributed cache product like Memcached supports key-value pairs ony.
    </p>
    <hr />

    <h1>How do I debug and deveop my application which interacts with Redis?</h1>
    <p>
        While coding around Redis you have the the following options:
        <ol>
            <li>Install Redis locally</li>
            <li>Abstract away Redis by using an in-memory abstraction (IDistributedCache)</li>
        </ol>
        of interacting with directly with the Redis client or through an abstraction layer.
        Redis a client-server product which listens on a specific port for incoming requests
    </p>
    <h2>Option - When would I need to install Redis locally?</h2>
    <p>The following scenarios come to my mind:</p>
    <ol>
        <li>You are using the advanced features of Redis such as pub-sub and need to develop/debug locally to test the behaviour</li>
        <li>You are using simple key-value caching, you intend on doing a smoke test of your ASP.NET Core Web app or ASP.NET Azure trigger function and want to debug locally with an actual Redis implementation</li>
    </ol>

    <h2>Option - When is it enough to just use the in-memory abstraction (IDistributedCache)</h2>
    If your scope is limited to key-value pair caching then the interface <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache?view=dotnet-plat-ext-3.1">IDistributedCache</a> is your first point of call.
    The interface <strong>IDistributedCache</strong> is implemented in the assembly <strong>Microsoft.Extensions.Caching.Abstractions.dll</strong>. I have presented some of the methods below:
    <pre>
        public interface IDistributedCache
        {
            public byte[] Get (string key);
            public void Refresh (string key);
            public void Remove (string key);
            public void Set (string key, byte[] value, Microsoft.Extensions.Caching.Distributed.DistributedCacheEntryOptions options);
        }

    </pre>
    <script src="https://gist.github.com/sdg002/95bdb55c185bec276bd37484c27252bf.js"></script>
    <!-- 
        https://gist.github.com/sdg002/95bdb55c185bec276bd37484c27252bf
        -->
    <hr />

    <h1>Installing Redis server and client locally on Windows</h1>
        <ol>
            <li>Option - Redis has been coded and tested on Linux. Fortunately, an old port of Redis exists for Windows 10 and can downloaded from <a href="https://redislabs.com/ebook/appendix-a/a-3-installing-on-windows/a-3-2-installing-redis-on-window/">here</a> and <a href="https://github.com/dmajkic/redis/downloads">here</a>.</li>
            <li>Option - To run the most recent version of Redis, you could run <a href="https://redislabs.com/blog/redis-on-windows-10/">Redis via Windows Subsystem for Linux</a>. </li>
        </ol>
    <p>If you are following the first option, which is good enough for simple key-value caching, then further steps are below:
        <img src="images/redis-server-windows.png" />
    </p>
    <ol>
        <li>Download and extract the contents to a local folder. E.g. <strong>C:\RedisServer</strong></li>
        <li>Navigate to <strong>c:\RedisServer\</strong> and type '<strong>redis-server.exe</strong>' and then hit ENTER. If everything went well then you can expect this on the CMD prompt</li>
        <li>
            You should see the PORT number (6379) where Redis is listening for active connections
        </li>
        <li>
            If the port used by Redis is already locked down by another process then you could use a command line option to specify the port.
        </li>
    </ol>
    <hr />

    <h1>Redis command line client</h1>
    <p>When you download the Windows 10 port of Redis , the package also includes a client executable <strong>redis-cli.exe</strong>.
        The CLI can help you test the server and carry out basic data manipulations as shown in the examples below.
        <br />
        <img src="images/redis-client-windows.PNG"/>
    </p>
    <h2>How to launch and connect to the server?</h2>
    <pre>
        redis-cli.exe -h localhost -p 6379
    </pre>

    <h2>List all keys</h2>
    <pre>
        redis localhost:6379> keys *

        39) "foo:rand:000000000016"
        40) "foo:rand:000000000017"
        41) "foo:rand:000000000018"
        42) "foo:rand:000000000019"
        43) "mykey-f9d21bca-48f6-4cf8-b68d-1652b9533633"
        44) "mykey-43d5b08a-5b60-4c72-8820-dcb6f6372b4b"

    </pre>

    <h2>Delete a specific key</h2>
    <pre>
        redis localhost:6379> del mykey-0001
    </pre>

    <h2>Delete all keys</h2>
    <pre>
        redis localhost:6379> flushall
    </pre>

    <hr />

    <h2>Set a key-value cached item</h2>
    <pre>        
        localhost:6379> set key001 value001
        Ok
    </pre>

    <h2>Get a cached item give the key</h2>
    <pre>
        localhost:6379> get key001
        "value001"
    </pre>
    <hr />


    <h1>C# client application  - Programming with StackExchange general purpose client</h1>

    <p></p>
    <pre>
    ```
    Install-Package StackExchange.Redis
    ```
    </pre>

    <h2>C# client application  - Programming with IDistributedCache</h2>
    <p>to be done</p>

    <h2>Dependency injection</h2>
    <p>to be done</p>

    <h2>Is it compulsory to intall Redis server locally?</h2>
    <p>to be done</p>


    <h2>Is it compulsory to intall Redis server locally?</h2>
    <p>to be done</p>

    <hr />
    <h1>Getting started with Redis on Azure</h1>

    <h2>Creating a Redis cache using the Portal</h2>
    <p>to be done</p>
    <h2>Creating a Redis cache using PowerShell</h2>
    <p>to be done</p>

    <h2>ARM templates</h2>
    <p>
        https://github.com/Azure/azure-quickstart-templates/tree/master/101-redis-cache
    </p>

    <h2>How to get the connection string?</h2>

    <pre>
        $cn=blah-getrediscnstring
    </pre>

    <pre>
        [TestMethod]
        public void Basic_Set_And_Get()
        {
            IDatabase db = _redis.GetDatabase();

            for (int i = 0; i < MAXITEMCOUNT; i++)
            {
                string key = $"mykey-{Guid.NewGuid()}";
                string value = $"abcdefg-{Guid.NewGuid()}";
                db.StringSet(key, value);
                string valueFromCache = db.StringGet(key);
                Trace.WriteLine($"Value of key:{key}, value:{valueFromCache}");
                Assert.AreEqual(valueFromCache, value);
            }
        }
    </pre>
    <hr />

    <h1>Advanced features of Redis not discussed here</h1>
    <p>
        to be done. A short bulleted list
    </p>


</body>
</html>